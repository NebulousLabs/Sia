package wallet

import (
	"errors"
	"fmt"

	"github.com/NebulousLabs/Sia/build"
	"github.com/NebulousLabs/Sia/crypto"
	"github.com/NebulousLabs/Sia/modules"
	"github.com/NebulousLabs/Sia/types"
	"github.com/NebulousLabs/bolt"
)

const scanMultiplier = 4 // how many more keys to generate after each scan iteration

const outputSize = 350 // approx. size in bytes of an output and accompanying signature

// numInitialKeys is the number of keys generated by the seedScanner before
// scanning the blockchain for the first time.
var numInitialKeys = func() uint64 {
	switch build.Release {
	case "dev":
		return 10e3
	case "standard":
		return 1e6
	case "testing":
		return 1e3
	default:
		panic("unrecognized build.Release")
	}
}()

// maxScanKeys is the number of maximum number of keys the seedScanner will
// generate before giving up.
var maxScanKeys = func() uint64 {
	switch build.Release {
	case "dev":
		return 1e6
	case "standard":
		return 100e6
	case "testing":
		return 100e3
	default:
		panic("unrecognized build.Release")
	}
}()

var errMaxKeys = fmt.Errorf("refused to generate more than %v keys from seed", maxScanKeys)

// A scannedOutput is an output found in the blockchain, along with the
// information necessary to spend it.
type scannedOutput struct {
	id           types.OutputID
	value        types.Currency
	spendableKey spendableKey
}

// A seedScanner scans the blockchain for addresses that belong to a given
// seed.
type seedScanner struct {
	dustThreshold    types.Currency              // minimum value of outputs to be included
	keys             map[types.UnlockHash]uint64 // map address to seed index
	largestIndexSeen uint64                      // largest index that has appeared in the blockchain
	seed             modules.Seed
	siacoinOutputs   map[types.SiacoinOutputID]scannedOutput
	siafundOutputs   map[types.SiafundOutputID]scannedOutput
}

func (s *seedScanner) numKeys() uint64 {
	return uint64(len(s.keys))
}

// generateKeys generates n additional keys from the seedScanner's seed.
func (s *seedScanner) generateKeys(n uint64) {
	initialProgress := s.numKeys()
	for i, k := range generateKeys(s.seed, initialProgress, n) {
		s.keys[k.UnlockConditions.UnlockHash()] = initialProgress + uint64(i)
	}
}

// ProcessConsensusChange scans the blockchain for information relevant to the
// seedScanner.
func (s *seedScanner) ProcessConsensusChange(cc modules.ConsensusChange) {
	// update outputs
	for _, diff := range cc.SiacoinOutputDiffs {
		if diff.Direction == modules.DiffApply {
			if index, exists := s.keys[diff.SiacoinOutput.UnlockHash]; exists && diff.SiacoinOutput.Value.Cmp(s.dustThreshold) > 0 {
				s.siacoinOutputs[diff.ID] = scannedOutput{
					id:           types.OutputID(diff.ID),
					value:        diff.SiacoinOutput.Value,
					spendableKey: generateSpendableKey(s.seed, index),
				}
			}
		} else if diff.Direction == modules.DiffRevert {
			// NOTE: DiffRevert means the output was either spent or was in a
			// block that was reverted.
			if _, exists := s.keys[diff.SiacoinOutput.UnlockHash]; exists {
				delete(s.siacoinOutputs, diff.ID)
			}
		}
	}
	for _, diff := range cc.SiafundOutputDiffs {
		if diff.Direction == modules.DiffApply {
			// do not compare against dustThreshold here; we always want to
			// sweep every siafund found
			if index, exists := s.keys[diff.SiafundOutput.UnlockHash]; exists {
				s.siafundOutputs[diff.ID] = scannedOutput{
					id:           types.OutputID(diff.ID),
					value:        diff.SiafundOutput.Value,
					spendableKey: generateSpendableKey(s.seed, index),
				}
			}
		} else if diff.Direction == modules.DiffRevert {
			// NOTE: DiffRevert means the output was either spent or was in a
			// block that was reverted.
			if _, exists := s.keys[diff.SiafundOutput.UnlockHash]; exists {
				delete(s.siafundOutputs, diff.ID)
			}
		}
	}

	// update s.largestIndexSeen
	for _, diff := range cc.SiacoinOutputDiffs {
		if index, exists := s.keys[diff.SiacoinOutput.UnlockHash]; exists && index > s.largestIndexSeen {
			s.largestIndexSeen = index
		}
	}
	for _, diff := range cc.SiafundOutputDiffs {
		if index, exists := s.keys[diff.SiafundOutput.UnlockHash]; exists && index > s.largestIndexSeen {
			s.largestIndexSeen = index
		}
	}
}

// scan subscribes s to cs and scans the blockchain for addresses that belong to
// s's seed. If scan returns errMaxKeys, additional keys may need to be
// generated to find all the addresses.
func (s *seedScanner) scan(cs modules.ConsensusSet) error {
	// generate a bunch of keys and scan the blockchain looking for them. If
	// none of the 'upper' half of the generated keys are found, we are done;
	// otherwise, generate more keys and try again (bounded by a sane
	// default).
	//
	// NOTE: since scanning is very slow, we aim to only scan once, which
	// means generating many keys.
	numKeys := numInitialKeys
	for s.numKeys() < maxScanKeys {
		s.generateKeys(numKeys)
		if err := cs.ConsensusSetSubscribe(s, modules.ConsensusChangeBeginning); err != nil {
			return err
		}
		if s.largestIndexSeen < s.numKeys()/2 {
			cs.Unsubscribe(s)
			return nil
		}
		// increase number of keys generated each iteration, capping so that
		// we do not exceed maxScanKeys
		numKeys *= scanMultiplier
		if numKeys > maxScanKeys-s.numKeys() {
			numKeys = maxScanKeys - s.numKeys()
		}
	}
	cs.Unsubscribe(s)
	return errMaxKeys
}

// newSeedScanner returns a new seedScanner.
func newSeedScanner(seed modules.Seed) *seedScanner {
	return &seedScanner{
		seed:           seed,
		keys:           make(map[types.UnlockHash]uint64),
		siacoinOutputs: make(map[types.SiacoinOutputID]scannedOutput),
		siafundOutputs: make(map[types.SiafundOutputID]scannedOutput),
	}
}

type keyScanner struct {
	dustThreshold  types.Currency
	keys           map[types.UnlockHash]spendableKey
	siacoinOutputs map[types.SiacoinOutputID]scannedOutput
	siafundOutputs map[types.SiafundOutputID]scannedOutput
}

// ProcessConsensusChange scans the blockchain for information relevant to the
// v033xScanner.
func (s *keyScanner) ProcessConsensusChange(cc modules.ConsensusChange) {
	for _, diff := range cc.SiacoinOutputDiffs {
		if diff.Direction == modules.DiffApply {
			if sk, exists := s.keys[diff.SiacoinOutput.UnlockHash]; exists && diff.SiacoinOutput.Value.Cmp(s.dustThreshold) > 0 {
				s.siacoinOutputs[diff.ID] = scannedOutput{
					id:           types.OutputID(diff.ID),
					value:        diff.SiacoinOutput.Value,
					spendableKey: sk,
				}
			}
		} else if diff.Direction == modules.DiffRevert {
			// NOTE: DiffRevert means the output was either spent or was in a
			// block that was reverted.
			if _, exists := s.keys[diff.SiacoinOutput.UnlockHash]; exists {
				delete(s.siacoinOutputs, diff.ID)
			}
		}
	}
	for _, diff := range cc.SiafundOutputDiffs {
		if diff.Direction == modules.DiffApply {
			// do not compare against dustThreshold here; we always want to
			// sweep every siafund found
			if sk, exists := s.keys[diff.SiafundOutput.UnlockHash]; exists {
				s.siafundOutputs[diff.ID] = scannedOutput{
					id:           types.OutputID(diff.ID),
					value:        diff.SiafundOutput.Value,
					spendableKey: sk,
				}
			}
		} else if diff.Direction == modules.DiffRevert {
			// NOTE: DiffRevert means the output was either spent or was in a
			// block that was reverted.
			if _, exists := s.keys[diff.SiafundOutput.UnlockHash]; exists {
				delete(s.siafundOutputs, diff.ID)
			}
		}
	}
}

func (s *keyScanner) scan(cs modules.ConsensusSet) error {
	if err := cs.ConsensusSetSubscribe(s, modules.ConsensusChangeBeginning); err != nil {
		return err
	}
	cs.Unsubscribe(s)
	return nil
}

func newKeyScanner(savedKeys []spendableKey) *keyScanner {
	keys := make(map[types.UnlockHash]spendableKey)
	for _, sk := range savedKeys {
		keys[sk.UnlockConditions.UnlockHash()] = sk
	}
	return &keyScanner{
		keys:           keys,
		siacoinOutputs: make(map[types.SiacoinOutputID]scannedOutput),
		siafundOutputs: make(map[types.SiafundOutputID]scannedOutput),
	}
}

// sweepOutputs sweeps the supplied siacoin and siafund outputs into the wallet.
func (w *Wallet) sweepOutputs(scos, sfos []scannedOutput) (coins, funds types.Currency, err error) {
	// get an address to spend into
	var uc types.UnlockConditions
	err = w.db.Update(func(tx *bolt.Tx) error {
		var err error
		uc, err = w.nextPrimarySeedAddress(tx)
		return err
	})
	if err != nil {
		return
	}

	// construct a transaction that spends the outputs
	// TODO: this may result in transactions that are too large.
	tb := w.StartTransaction()
	defer func() {
		if err != nil {
			tb.Drop()
		}
	}()
	var sweptCoins, sweptFunds types.Currency // total values of swept outputs
	for _, output := range scos {
		// construct a siacoin input that spends the output
		tb.AddSiacoinInput(types.SiacoinInput{
			ParentID:         types.SiacoinOutputID(output.id),
			UnlockConditions: output.spendableKey.UnlockConditions,
		})
		// add a signature for the input
		sweptCoins = sweptCoins.Add(output.value)
	}
	for _, output := range sfos {
		// construct a siafund input that spends the output
		tb.AddSiafundInput(types.SiafundInput{
			ParentID:         types.SiafundOutputID(output.id),
			UnlockConditions: output.spendableKey.UnlockConditions,
		})
		// add a signature for the input
		sweptFunds = sweptFunds.Add(output.value)
	}

	// estimate the transaction size and fee. NOTE: this equation doesn't
	// account for other fields in the transaction, but since we are
	// multiplying by maxFee, lowballing is ok
	estTxnSize := (len(scos) + len(sfos)) * outputSize
	_, maxFee := w.tpool.FeeEstimation()
	estFee := maxFee.Mul64(uint64(estTxnSize))
	tb.AddMinerFee(estFee)

	// calculate total siacoin payout
	if sweptCoins.Cmp(estFee) > 0 {
		coins = sweptCoins.Sub(estFee)
	}
	funds = sweptFunds

	switch {
	case coins.IsZero() && funds.IsZero():
		// if we aren't sweeping any coins or funds, then just return an
		// error; no reason to proceed
		return types.Currency{}, types.Currency{}, errors.New("transaction fee exceeds value of swept outputs")

	case !coins.IsZero() && funds.IsZero():
		// if we're sweeping coins but not funds, add a siacoin output for
		// them
		tb.AddSiacoinOutput(types.SiacoinOutput{
			Value:      coins,
			UnlockHash: uc.UnlockHash(),
		})

	case coins.IsZero() && !funds.IsZero():
		// if we're sweeping funds but not coins, add a siafund output for
		// them. This is tricky because we still need to pay for the
		// transaction fee, but we can't simply subtract the fee from the
		// output value like we can with swept coins. Instead, we need to fund
		// the fee using the existing wallet balance.
		tb.AddSiafundOutput(types.SiafundOutput{
			Value:      funds,
			UnlockHash: uc.UnlockHash(),
		})
		err = tb.FundSiacoins(estFee)
		if err != nil {
			return types.Currency{}, types.Currency{}, errors.New("couldn't pay transaction fee on swept funds: " + err.Error())
		}

	case !coins.IsZero() && !funds.IsZero():
		// if we're sweeping both coins and funds, add a siacoin output and a
		// siafund output
		tb.AddSiacoinOutput(types.SiacoinOutput{
			Value:      coins,
			UnlockHash: uc.UnlockHash(),
		})
		tb.AddSiafundOutput(types.SiafundOutput{
			Value:      funds,
			UnlockHash: uc.UnlockHash(),
		})
	}

	// add signatures for all coins and funds (manually, since tb doesn't have
	// access to the signing keys)
	txn, parents := tb.View()
	for _, output := range scos {
		sk := output.spendableKey
		addSignatures(&txn, types.FullCoveredFields, sk.UnlockConditions, crypto.Hash(output.id), sk)
	}
	for _, output := range sfos {
		sk := output.spendableKey
		addSignatures(&txn, types.FullCoveredFields, sk.UnlockConditions, crypto.Hash(output.id), sk)
	}
	// Usually, all the inputs will come from swept outputs. However, there is
	// an edge case in which inputs will be added from the wallet. To cover
	// this case, we iterate through the SiacoinInputs and add a signature for
	// any input that belongs to the wallet.
	w.mu.RLock()
	for _, input := range txn.SiacoinInputs {
		if key, ok := w.keys[input.UnlockConditions.UnlockHash()]; ok {
			addSignatures(&txn, types.FullCoveredFields, input.UnlockConditions, crypto.Hash(input.ParentID), key)
		}
	}
	w.mu.RUnlock()

	// submit the transaction
	txnSet := append(parents, txn)
	err = w.tpool.AcceptTransactionSet(txnSet)
	return
}
