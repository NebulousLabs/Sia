This file is meant to document the flow of information in the codebase.

Verifying and Applying a Block:

1. Check lists of blocks to see if the block is already known to the program.
2. Check that the block meets the target.
3. Check that the block is not in the future, and call sleep() if it is.
4. Check that the block is not in the past.
5. Check that the transaction hash matches the transaction list.
6. Add the block to the list of blocks, creating a new fork.
7. Broadcast the block to all known peers.
8. If the new fork is not heavier than the heaviest known fork, stop here.
9. Rewind blocks from the current fork until a common parent with the new fork is found.
10. For each block that needs to be added, repeat the remaining steps.
11. If a block fails, add it and all of its children (recursively) to the bad blocks list, rewind back to the common parent, and then re-apply all the blocks to restore the state to the old haviest fork.
12. Verify and then apply each transaction, adding up the total volume of miner fees in each.
13. Create any outputs from contracts with missed storage proofs.
14. Create any outputs from terminated contracts, and then delete the contract.
15. Add coin inflation to the miner subsidy, and create an output for the miner subsidy.
16. Update the values for the current block and current path.

Verifying a Transaction:

1. Sum all of the inputs
2. Check that all inputs spend existing outputs.
3. Check that the spend conditions for each input match the hash of the output they spend.
4. Check that the timelock on each output has expired.
5. Check that no inputs are spent twice.
6. Add up miner fees, outputs, and contract funds, make sure that's less than the sum of all inputs.
7. Make sure there are no illegal values in the contracts.
8. Make sure all storage proofs are valid.
9. Make sure all signatures are non-frivilous and valid.
10. Make sure each input has fully satisfied its signature requirements.

Applying a Transaction:

1. Remove the transaction from the transaction pool.
2. Delete all inputs from the unspent outputs list.
3. Add all financial outputs to the unspent outputs list.
4. Add all outputs created by the storage proofs.
5. Add all open contracts created by the file contracts.
6. (scan arbitrary data to fill out the host db)

Removing a Block:

1. Remove the output responsible for the miner subsidy.
2. Remove any outputs created from terminated contracts, and then restore the contract.
3. Remove any outputs created from missed storage proofs.
4. Remove each transaction that was in the block.
5. Update the values for the current block and current path.

Removing a Transaction:

1. (scan arbitrary data and remove any hosts from the host db)
2. Delete all open contracts created by the file contracts.
3. Delete all outputs created by the storage proofs.
4. Delete all financial outputs created by the transaction.
5. Restore all transaction inputs to the unspent outputs list.
6. Add the transaction back to the transaction pool.
