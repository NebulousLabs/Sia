\documentclass[twocolumn]{article}
\usepackage{amsmath}

\begin{document}
\frenchspacing

\title{Sia: Simple Decentralized Storage - Draft}

\author{
{\rm David Vorick}\\
Nebulous Inc.\\
david@nebulouslabs.com
\and
{\rm Luke Champine}\\
Nebulous Inc.\\
luke@nebulouslabs.com
}

\maketitle

\subsection*{Abstract}
The authors introduce Sia, a platform for decentralized storage.
Sia enables the formation of storage contracts between peers.
Contracts are agreements between a storage provider and their client, defining what data will be stored and at what price.
They require the storage provider to prove, at regular intervals, that they are still storing their client's data.

Contracts are stored in a blockchain, making them publicly auditable.
In this respect, Sia can be viewed as a Bitcoin derivative that includes support for such contracts.
Sia will initially be implemented as an altcoin, and later financially connected to Bitcoin via a two-way peg.

\section{Introduction}
Sia is a decentralized cloud storage platform that intends to compete with existing storage solutions, at both the P2P and enterprise level.
Instead of renting storage from a centralized provider, peers on Sia rent storage from each other.
Sia itself stores only the storage contracts formed between parties, defining the terms of their arrangement.
A blockchain, similar to Bitcoin \cite{btc, btcdg}, is used for this purpose.

By forming a contract, a storage provider agrees to store a client's data, and to periodically submit proof of their continued storage until the contract expires.
The provider is compensated for every proof they submit, and penalized for missing a proof.
Since these proofs are publicly verifiable (and are publicly available in the blockchain), network consensus can be used to automatically enforce storage contracts.
Importantly, this means that clients do not need to personally verify storage proofs; they can simply upload their file and let the network do the rest.

We acknowledge that storing data on a single untrusted host guarantees little in the way of availability, bandwidth, or general quality of service.
Instead, we recommend storing data redundantly across multiple hosts.
In particular, the use of erasure codes can enable high availability without excessive redundancy.

Sia will initially be implemented as a blockchain-based altcoin.
Future support for a two-way peg with Bitcoin is planned, as discussed in ``Enabling Blockchain Innovations with Pegged Sidechains'' \cite{side}.
The Sia protocol largely resembles Bitcoin except for the changes noted below.

\section{General Structure}
Sia's primary departure from Bitcoin lies in its transactions.
Bitcoin uses a scripting system to enable a range of transaction types, such as pay-to-public-key-hash and pay-to-script-hash.
Sia opts instead to use an $M$--of--$N$ multi-signature hash scheme for all transactions, eschewing the scripting system entirely.
This reduces complexity and attack surface.

Sia also extends transactions to enable the creation and enforcement of storage contracts.
Two extensions are needed to accomplish this: contracts and proofs.
File contracts declare the intention of a storage provider to store a file with a certain size and hash.
They define the regularity with which a provider must submit storage proofs.
The specifics of these transaction types are defined in sections \ref{sec:contracts} and \ref{sec:storage}, respectively.

\section{Transactions}
A transaction contains the following fields: \\
\begin{tabular}{| l | l |}
	\hline
	\textbf{Field} & \textbf{Description} \\ \hline
	Version        & Protocol version number \\ \hline
	Arbitrary Data & Used for metadata or otherwise \\ \hline
	Miner Fee      & Reward given to miner \\ \hline
	Inputs         & Incoming funds \\ \hline
	Outputs        & Outgoing funds (optional) \\ \hline
	File Contract  & See: File Contracts (optional) \\ \hline
	Storage Proof  & See: Proof of Storage (optional) \\ \hline
	Signatures     & Signatures from each input \\ \hline
\end{tabular}

\subsection{Inputs and Outputs}
An output comprises a volume of coins.
Each output has an associated identifier, which is derived from the transaction that the output appeared in.
The ID of output $i$ in transaction $t$ is defined as:
\[
	H(t || \text{``output''} || i)
\]
where $H$ is a cryptographic hashing function, and ``output'' is a string literal.
The block reward and miner fees have special output IDs, given by:
\[
	H(H(\text{Block Header}) || \text{``blockreward''})
\]
Every input must come from a prior output, so an input is simply an output ID.

Inputs and outputs are also paired with a set of \textit{spend conditions}.
Inputs contain the spend conditions themselves, while outputs contain their Merkle root hash \cite{merkle}.

\subsection{Spend Conditions}
Spend conditions are properties that must be met before coins are ``unlocked'' and can be spent.
The spend conditions include a time lock and a set of public keys, and the number of signatures required.
An output cannot be spent until the time lock has expired and enough of the specified keys have added their signature.

The spend conditions are hashed into a Merkle tree, using the time lock, the number of signatures required, and the public keys as leaves.
The root hash of this tree is used as the address to which the coins are sent.
In order to spend the coins, the spend conditions corresponding to the address hash must be provided.
The use of a Merkle tree allows parties to selectively reveal information in the spend conditions.
For example, the time lock can be revealed without revealing the number of public keys or the number of signatures required.

\subsection{Signatures}
Each input in a transaction must be signed.
The cryptographic signature itself is paired with an input ID, a time lock, and a set of flags indicating which parts of the transaction have been signed.
The input ID indicates which input the signature is being applied to.
The time lock specifies when the signature becomes valid.
Any subset of fields in the transaction can be signed, with the exception of the Version and the signature itself (as this would be impossible).
There is also a flag to indicate that the whole transaction should be signed, except for the signatures.
This allows for more nuanced transaction schemes.

The actual data being signed, then, is a concatenation of the time lock, input ID, flags, and every flagged field.
Every such signature in the transaction must be valid for the transaction to be accepted.

\section{File Contracts}
\label{sec:contracts}
A file contract is an agreement between a storage provider and a client.
At the core of a file contract is the file's Merkle root hash.
To construct this hash, the file is split into segments of constant size and hashed into a Merkle tree.
The root hash, along with the total size of the file, can be used to verify storage proofs.

File contracts also specify a duration, challenge frequency, and payout parameters, including the reward for a valid proof, the reward for an invalid or missing proof, and the maximum number of proofs that can be missed.
The challenge frequency is the maximum number of blocks that can elapse between storage proofs (also called a \textit{challenge window}).
As soon as one challenge window closes, the next opens.
Submitting a valid proof during the challenge window triggers an automatic payment to the ``valid proof'' address (presumably the host).
If, at the end of the challenge window, no valid proof has been submitted, coins are instead sent to the ``missed proof'' address (presumably the client).
Contracts define a maximum number of proofs that can be missed; if this number is exceeded, the contract becomes invalid.

If the file contract is still valid at the end of the specified duration, it \textit{successfully terminates}.
Conversely, if the contract funds are exhausted before the duration elapses, or if the maximum number of missed proofs is exceeded, the contract \textit{unsuccessfully terminates}.
Each of these potential outcomes (valid proof, invalid proof, successful termination, unsuccessful termination) has an associated recipient.
The funds for these various payouts are provided by the inputs to the transaction.

The rewards for completed proofs and missed proofs create a new transaction output belonging to the recipient specified in the contract.
The recipient will be a hash of the output spend conditions for the new output.
The ID of a contract is defined as:
\[
	H(\text{transaction} || \text{``contract''} || i)
\]
where $i$ is the index of the contract within the transaction.
The output ID of a storage proof is defined as:
\[
	H(\text{contract ID} || \text{outcome} || W_i)
\]
Where $W_i$ is the window index, i.e. the number of windows that have elapsed since the contract was formed.
The outcome has four possible values, corresponding to the four potential outcomes listed above.
These are represented by the strings ``validproof'', ``missedproof'', ``successfultermination'', and ``unsucessfultermination''.

\section{Proof of Storage}
\label{sec:storage}
Storage proof transactions are periodically submitted in order to fulfill file contracts.
Each storage proof targets a specific file contract.
A storage proof does not need to have any inputs or outputs; only a contract ID and the proof data are required.

\subsection{Algorithm}
Hosts prove their storage by providing a segment of the original file, along with a list of hashes from the file's Merkle tree.
This information is sufficient to prove that the segment came from the original file.
Because the proofs are submitted to the blockchain, everyone can verify that the provider has provided a valid proof.
Each storage proof uses a randomly selected segment.
The random seed for challenge window $W_i$ is given by:
\[
	H(\text{contract ID} || H(B_(i-1)))
\]
where $B_{i-1}$ is the block immediately prior to the beginning of $W_i$.

If the provider is consistently able to demonstrate possession of a random segment, then the provider is very likely storing the whole file.
A provider storing only 50\% of the file will be unable to complete approximately 50\% of the proofs.

\subsection{Block Withholding Attacks}
The random number generator is subject to manipulation via block withholding attacks, in which the attacker withholds blocks until they find one that will produce a favorable random number.
However, the attacker has only one chance to manipulate the random number for a particular challenge.
Furthermore, withholding a block to manipulate the random number will cost the attacker the block reward.

If an attacker is able to mine 50\% of the blocks, then 50\% of the challenges can be manipulated.
Nevertheless, the remaining 50\% are still random, so the attacker will still fail some storage proofs.
Specifically, they will fail half as many as they would without the withholding attack.

To protect against such attacks, clients can specify a high challenge frequency and large penalties for missing proofs.
These precautions should be sufficient to deter any financially-motivated attacker that controls less than 50\% of the network's hashing power.
Regardless, clients are advised to plan around potential Byzantine attacks, which may not be financially motivated.

\subsection{Closed Window Attacks}
Hosts can only complete a storage proof if their proof transaction makes it into the blockchain.
Miners could maliciously exclude storage proofs from blocks, depriving themselves of transaction fees but forcing a penalty on storage providers.
Alternatively, miners could extort hosts by requiring large fees to include storage proofs, knowing that they are more important than the average transaction.
This is termed a \textit{closed window attack}, because the malicious miner has artificially ``closed the window.''

The defense for this is to use a large window size.
Hosts can reasonably assume that some percentage of miners will include their proofs in return for a transaction fee.
Because hosts consent to all file contracts, they are free to reject any contract that they feel leaves them vulnerable to closed window attacks.

\section{Arbitrary Transaction Data}
Each transaction has an arbitrary data field which can be used for any type of information.
Nodes will be required to store the arbitrary data if it is signed by any signature in the transaction.
Nodes will initially accept up to 16 KB of arbitrary data per block.

The arbitrary data provides storage providers and clients with a decentralized way to organize themselves.
It can be used to advertise available space or files seeking a host, or to create a decentralized file tracker.

Arbitrary data could also be used to implement other types of soft forks.
This would be done by creating an ``anyone-can-spend'' output but with restrictions specified in the arbitrary data.
Miners that understand the restrictions can block any transaction that spends the output without satisfying the necessary stipulations.
Naive nodes will stay synchronized without needing to be able to parse the arbitrary data.

\section{Storage Ecosystem}
Sia relies on an ecosystem that facilitates decentralized storage.
Storage providers can use the arbitrary data field to announce themselves as providers to the network.
This can be done using standardized template that clients will be able to read.
Clients can read these announcements and create a database of providers.
They can then determine a set of providers that they trust and create file contracts with those providers.
Micropayment channels \cite{mpc} can be used to negotiate downloading the file. % should probably expand this a bit, or move it to another section.

\subsection{Storage Provider Protections}
A contract requires consent from both the storage provider and the client, allowing the provider to reject unfavorable terms or unwanted (e.g. illegal) files.
The provider may also refuse to sign a contract until the entire file has been uploaded to them.
The contract terms give storage providers flexibility.
They can advertise themselves as minimally reliable, offering a low price and a agreeing to minimal penalties for losing files;
or they can advertise themselves as highly reliable, offering a higher price and agreeing to harsher penalties for losing files.
An efficient market will optimize storage strategies.

Storage providers are vulnerable to denial of service attacks, which could prevent them from submitting storage proofs or transferring files.
We note that certain penalty structures may incentivize DoS attacks against the provider.
It is the responsibility of the provider to protect themselves from such attacks.

\subsection{Client Protections}
Clients can use erasure codes, such as regenerating codes \cite{reg}, to safeguard against hosts going offline.
In an erasure coding scheme, file data is split into $n$ overlapping pieces, such that the file can be recovered from any subset of at least $m$ unique pieces.
(The values of $n$ and $m$ vary based on the erasure code and redundancy factor.)
Each piece is then encrypted and stored across many storage providers.
This allows a client to attain high file availability even if the average network reliability is low.
As an extreme example, if only 10 out of 100 pieces are needed to recover the file, then the client is actually relying on the 10 most reliable hosts, rather than the average reliability.
Availability can be further improved by rehosting file pieces whose hosts have gone offline.
Other metrics benefit from this strategy as well; the client can reduce latency by downloading from the closest 10 hosts, or increase download speed by downloading from the 10 fastest hosts.
These downloads can be run in parallel to maximize available bandwidth.

\subsection{Uptime Incentives}
The storage proofs contain no mechanism to enforce constant uptime.
There are also no provisions that require storage providers to upload files to clients upon request.

However, providers and clients can create micropayment channels to facilitate downloads.
If the client is offering a reward for sending them a file, providers will be incentivized to collect the reward.
Providers are thus incentivized to maximum uptime, in order to collect as many rewards as possible.
Clients can also incentivize greater throughput and lower latency via proportionally larger rewards.
Clients could even perform random ``checkups'' that reward providers simply for being online, even if they do not wish to download anything.
However, we reiterate that uptime incentives are not part of the Sia protocol; they are entirely dependent on client behavior.

\subsection{Basic Reputation System}
Clients need a reliable method for picking quality storage providers.
Looking at provider history is insufficient, because the history could be faked.
A provider could repeatedly form contracts with itself, agreeing to store large ``fake'' files, such as a file containing only zeros or a similar pattern.
It would be trivial to perform storage proofs on such data without actually storing anything.

To mitigate this Sybil attack, clients can require that providers that announce themselves in the arbitrary data section also include a large volume of time locked coins.
If 10 coins are time locked 14 days into the future, then the host can be said to have created a lock valued at 140 coin-days.
By favoring hosts that have created high-value locks, clients can mitigate the risk of Sybil attacks, as valuable locks are not trivial to create.

Each client can choose their own equation for picking hosts, and can use a large number of factors, including price, lock value, volume of storage being offered, and the penalties hosts are willing to pay for losing files.
More complex systems, such as those that use human review or other metrics, could be implemented out-of-band in a more centralized setting.

\section{Siafunds}
Sia is a product of Nebulous Incorporated.
Nebulous is a for-profit company, and Sia is intended to become a primary source of income for the company.
Currency premining is not a stable source of income, as it requires creating a new currency and tethering the company to the currency's increasing value. %clarify
When the company needs to spend money, it must trade away portions of its source of income.
Additionally, premining means that one entity has control over a large volume of the currency, and therefore potentially large and disruptive control over the market.

Instead, Nebulous intends to generate revenue from Sia in a manner proportional to the value added by Sia, as determined by the value of the contracts set up between clients and hosts.
This is accomplished by imposing a fee on all contracts.
When a contract is created, 10\% of the contract fund is removed and distributed to the holders of \textit{siafunds}.
Nebulous Inc. will initially hold ~95\% of the siafunds, and the early crowd-fund backers of Sia will hold the remaining ~5\%.

Siafunds can be sent to other addresses, in the same way that siacoins can be sent to other addresses.
They cannot, however, be used to fund contracts or miner fees.
When siafunds are transferred to a new address, an additional unspent output is created, containing all of the siacoins that have been earned by the siafunds since their previous transfer.
These siacoins are sent to the same address as the siafunds.

% this section feels very disjointed.
\section{Economics of Sia}
The supply of siacoins will increase permanently.
Initially, 300,000 coins will be minted every block.
This number will decrease by 1 coin per block, until a minimum of 30,000 coins per block is reached.
% need equation/explanation; maybe use a table for growth rates
At the end of year 1, the annual growth in supply will be 90\%.
Years 2, 3, 4, 5, 8, and 20 will have annual growths of 39\%, 21\%, 11.5\%, 4.4\%, 3.2\%, and 2.3\%, respectively.

% is this paragraph necessary? I don't really understand why it's included.
Coins must be locked down when creating contracts.
When contracts are created, the coins funding the contract are taken out of circulation until the contract begins making payments.
The full amount of coins are not returned to circulation until the contract has terminated.
The number of coins locked down will be even greater if the host is offering a large refund for losing the file.
As Sia's usage as a storage platform goes up, the scarcity of the coin being used will also go up.

Hosts are only dependent on the stability of the value of the siacoin for the duration of their contracts.
Hosts can continually reprice contracts as the siacoin shifts in value.
Siacoins also derive value from the simple fact that they enable the formation of contracts.
Future additions to support more currencies through the use of two-way pegs will provide additional security for hosts.

\section{Under Consideration}
The primary foundation of Sia has been established above.
Other considerations, such as mining algorithms, block time, etc., can be assumed to mirror those found in Bitcoin.

Giving careful attention to ``A Treatise on Altcoins'' \cite{alts}, we are considering the following changes to Sia for the overall improvement of the cryptocurrency.
We caution that these propositions have not yet been rigorously examined from a security standpoint.

\subsection{Flexible Contracts}
Contracts, in their present form, are fairly strict.
There is a set penalty for each missed storage proof, and a termination upon $n$ total missed storage proofs.
Increased flexibility in the penalty schedule may be desirable.

Contracts are also permanent, creating what is essentially an uneditable file on the network.
There may be value in enabling clients and hosts to negotiate an updated file hash or other updated contract terms.
Updating the terms of the contract would require consent from all parties.

% \subsection{Proof of Existence Windows}
% In an attempt to partially resolve the closed window attacks, we could use a proof of existence strategy.
% A host can create a hash of the storage proof which they submit to the blockchain within the window.
% The host then has a greatly extended window in which they can demonstrate that the proof of storage was created during the required window.

% This has two advantages.
% First, an attacker cannot selectively exclude proof of existence hashes, because there's no way to figure out who owns each hash.
% Either the attacker doesn't include any unknown proof of existence hashes, or the attacker risks including undesired proof of existence hashes.
% Second, this allows hosts to submit small transactions to the network during peak hours and then the larger transactions when the traffic has died down.

% A further improvement would enable Merkle Tree proofs of existence.
% This would enable a host to submit multiple proofs of storage in a single proof of existence hash.

% delete/expand this section?
\subsection{Siafund the Miner fees}
Have some portion of siafunds contribute to the miner fees, which ensures that miners have compensation so long as Sia is being used for its core purpose - storage.

% \subsection{Miner Fee Adjustments}
% If a block has miner fees which are significantly higher than the fees in the current block, there is incentive for miners to re-mine the previous block and change who gets the miner fees.
% This can be mitigated by putting all of the fees into a pool which pays out 50\% every block, making re-mining unprofitable for any party with less than 50\% of the network hashing power.
% Link to discussion threads of this potential change.

% Additionally, miners have incentives not to propagate high fee transactions, because this will prevent other miners from mining the transaction and collecting the fees.
% It may be possible to construct a system using fee deterioration that means a miner has the highest expected total reward when the transaction is mined as soon as possible - regardless of who mines the transaction.
% Link to discussion threads of this potential change.

\subsection{More Frequent Target Adjustments}
% This section could use a few citations, but the discussion on this seems pretty well scattered. I could find things like the Kimoto Gravity Well, but other than alts.pdf I couldn't find any comments by respected individuals. I know that these discussions are out there, I've seen them before, just can't find them.
Bitcoin adjusts its block difficulty every 2016 blocks, with a target of 10 minutes per block.
This often means that the final blocks in a difficulty window are produced faster than 10 minutes (sometimes substantially) on account of rapid growth in available mining power.
To mitigate this effect, we are considering adjusting the difficulty after every block.

% I don't understand this paragraph
The bi-weekly adjustments to the Bitcoin difficulty can also cause coordinated drops in mining power---all at once, miners lose a percentage of their dollars-per-energy efficiency.
Difficulty adjustments every block creates a much smoother function for when mining rigs are no longer profitable.

The clamp on mining growth can also be increased.
The clamp serves to prevent an attacker from being easily manipulating the difficulty.
% 2,016,000 what?
In Bitcoin, raising the difficulty from 1000 to 4000 requires a minimum of 2,016,000 of work, and the difficulty can adjust by a maximum of 4x every week.
If the difficulty is being adjusted every block, however, and clamped at 1.001\% per block, an attacker will need 3,000,050 work to raise the difficulty from 1000 to 4000.
At this rate, the difficulty can shift by a maximum of 7.5x every week, which both increases the flexibility of the difficulty and makes difficulty raising attacks more difficult.

Though the difficulty will be adjusted every block, it will still be adjusted according to the amount of time taken to produce the previous 2016 blocks, preventing randomly fast or slow blocks from having large impact on the network.

% \subsection{Committing to State}
% One thing that could allow for substantially lighter weight clients is if the miners committed to the current state of the network, instead of just to the new transactions.
% This would mean creating a structure for a database that represents the state of the network and hashing it.
% We could follow suggestions similar to those presented in ``Ultimate blockchain compression'' \cite{ubc}.

% \subsection{Variance Enforced Merge Mining}
% Bitcoin enforces a number of leading 0s on a winning block.
% Sia could enforce something like a single leading 1, followed by a bunch of leading 0s.
% This creates the property that no hash is ever valid for both Bitcoin and Sia.

% The value to this is that the number of payouts a miner gets from finding blocks goes up.
% The total payout is still the same, but the number of payouts increases by the number of blocks that would have been valid for both.
% A block that solves the coin with the highest difficulty will always be valid for both blockchains.
% (I need to read more about merge mining before I publish this section)

\section{Conclusion}
Sia is a variant on the Bitcoin protocol that enables decentralized file storage via cryptographic contracts.
These contracts can be used to enforce storage agreements between clients and hosts.
After agreeing to store a file, a host must regularly submit storage proofs to the network.
The host will automatically be compensated for storing the file regardless of the behavior of the client.

Importantly, contracts do not require hosts to transfer files back to their client when requested.
Instead, an out-of-band ecosystem must be created to reward hosts for uploading. % what about the micropayments?
Clients and hosts must also find a way to coordinate; one mechanism would be the arbitrary data field in the blockchain.
Various precautions have been enumerated which mitigate Sybil attacks and the unreliability of hosts.

Siafunds are used as a mechanism of generating revenue for Nebulous Inc., the company responsible for the release and maintenance of Sia.
By using Siafunds instead of premining, Nebulous more directly correlates revenue to actual use of the network, and is largely unaffected by market games that malicious entities may play with the network currency.
Miners may also derive a part of their block subsidy from siafunds, with similar benefits.
Long term, we hope to add support for two-way-pegs with various currencies, which would enable consumers to insulate themselves from the instability of a single currency.

We believe Sia will provide a fertile platform for decentralized cloud storage in trustless environments.

\onecolumn
\begin{thebibliography}{9}

\bibitem{btc}
	Satoshi Nakamoto,
	\emph{Bitcoin: A Peer-to-Peer Electronic Cash System}.

\bibitem{merkle}
	R.C. Merkle,
	\emph{Protocols for public key cryptosystems},
	In Proc. 1980 Symposium on Security and	Privacy,
	IEEE Computer Society, pages 122-133, April 1980.

\bibitem{cpr}
	Hovav Shacham, Brent Waters,
	\emph{Compact Proofs of Retrievability},
	Proc. of Asiacrypt 2008, vol. 5350, Dec 2008, pp. 90-107.

\bibitem{reg}
	K. V. Rashmi, Nihar B. Shah, and P. Vijay Kumar,
	\emph{Optimal Exact-Regenerating Codes for Distributed Storage at the MSR and MBR Points via a Product-Matrix Construction}.

\bibitem{side}
	Adam Back, Matt Corallo, Luke Dashjr, Mark Friedenbach, Gregory Maxwell, Andrew Miller, Andrew Peolstra, Jorge Timon, Pieter Wuille,
	\emph{Enabling Blockchain Innovations with Pegged Sidechains}.

\bibitem{alts}
	Andrew Poelstra,
	\emph{A Treatise on Altcoins}.

\bibitem{ibf}
	Gavin Andresen,
	\emph{O(1) Block Propagation},
	https://gist.github.com/gavinandresen/e20c3b5a1d4b97f79ac2

\bibitem{hdw}
	Gregory Maxwell,
	\emph{Deterministic Wallets},
	https://bitcointalk.org/index.php?topic=19137.0

\bibitem{ubc}
	etotheipi,
	Ultimate blockchain compression w/ trust-free lite nodes, \newline
	https://bitcointalk.org/index.php?topic=88208.0

\bibitem{poc}
	Gregory Maxwell,
	\emph{Proof of Storage to make distributed resource consumption costly.} \newline
	https://bitcointalk.org/index.php?topic=310323.0

\bibitem{mpc}
	Mike Hearn,
	\emph{Rapidly-adjusted (micro)payments to a pre-determined party},\newline
	https://en.bitcoin.it/wiki/Contracts\#Example\_7:\_Rapidly-adjusted\_.28micro.29payments\_to\_a\_pre-determined\_party

\bibitem{btcdg}
	Bitcoin Developer Guide,
	https://bitcoin.org/en/developer-guide


\end{thebibliography}

\end{document}
